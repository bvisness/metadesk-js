/*
 * This file implements a parser for the Metadesk format by Dion Systems.
 *
 * Metadesk is a flexible, human-friendly data description format with a simple, uniform structure.
 * This simple structure is paired with a rich helper library that makes it easy to manipulate this
 * structure. Metadesk is richer than JSON, friendlier than XML, less confusing than YAML, and
 * easier to work with than all of the above.
 * 
 * This file serves as a reference implementation for a Metadesk parser. Its goal is to be a simple
 * and clear example of a Metadesk parser, not to be the most efficient. However, since Metadesk's
 * grammar is unambiguous and this implementation is simple, efficiency should not be a
 * significant problem.
 * 
 * TODO:
 * 
 * General advice:
 * - Consume all whitespace before handing off to another function. Whitespace is important; only
 *   consume it when you know you can.
 * Replace all while(true) with reasonably bounded generators
 * Remove TokenGroup in favor of simple constants
 * Elide whitespace tokens that immediately precede newline tokens
 */

const DEBUG = true;

enum NodeKind {
    Nil,
    
    // Generated by parser
    File,
    ErrorMarker,
    
    // Parsed from user Metadesk code
    Main,
    Tag,
    
    // // NOTE(rjf): User-created data structures
    // List,
    // Reference,
}

interface Node {
    kind: NodeKind,
    flags: NodeFlags,
    string: string,
    rawString: string,
    // TODO: offset,

    next: Node | undefined,
    prev: Node | undefined,
    parent: Node | undefined,

    children: Node[],
    tags: Node[],
}

function makeNode(kind: NodeKind, str: string, rawStr: string): Node {
    return {
        kind: kind,
        flags: NodeFlags.None,
        string: str,
        rawString: rawStr,

        next: undefined,
        prev: undefined,
        parent: undefined,

        children: [],
        tags: [],
    };
}

interface ParseResult {
    node: Node | undefined,
    errors: string[],
}

export function parse(source: string): ParseResult {
    const ctx = new ParseContext(source);
    
    const root = makeNode(NodeKind.File, "", source);
    root.children = _parseExplicitChildren(ctx)

    return {
        node: root,
        errors: ctx.errors,
    }
}

enum TokenKind {
    Invalid = 0,

    Identifier      = 1 << 0,
    Numeric         = 1 << 1,
    StringLiteral   = 1 << 2,
    Symbol          = 1 << 3,
    Reserved        = 1 << 4,
    Comment         = 1 << 5,
    Whitespace      = 1 << 6,
    Newline         = 1 << 7,

    BrokenComment       = 1 << 8,
    BrokenStringLiteral = 1 << 9,
    BadCharacter        = 1 << 10,

    All = ~0,
}

enum TokenGroup {
    Comment     = TokenKind.Comment,
    Whitespace  = TokenKind.Whitespace | TokenKind.Newline,
    Irregular   = TokenKind.Comment | TokenKind.Whitespace,
    Regular     = ~Irregular,
    Label       = TokenKind.Identifier
                    | TokenKind.Numeric
                    | TokenKind.StringLiteral
                    | TokenKind.Symbol,
    Error       = TokenKind.BrokenComment
                    | TokenKind.BrokenStringLiteral
                    | TokenKind.BadCharacter,
    
    All = ~0,
}

enum NodeFlags {
    None = 0,

    HasParenLeft    = 1 << 0,
    HasParenRight   = 1 << 1,
    HasBracketLeft  = 1 << 2,
    HasBracketRight = 1 << 3,
    HasBraceLeft    = 1 << 4,
    HasBraceRight   = 1 << 5,

    MaskSetDelimiters = 0x3F << 0,

    IsBeforeSemicolon   = 1 << 6,
    IsAfterSemicolon    = 1 << 7,
    IsBeforeComma       = 1 << 8,
    IsAfterComma        = 1 << 9,

    MaskSeparators = 0xF << 6,

    StringSingleQuote   = 1 << 10,
    StringDoubleQuote   = 1 << 11,
    StringTick          = 1 << 12,
    StringTriplet       = 1 << 13,
    
    MaskStringDelimiters = 0xF << 10,
    
    Numeric         = 1 << 14,
    Identifier      = 1 << 15,
    StringLiteral   = 1 << 16,
    Symbol          = 1 << 17,
    
    MaskLabelKind = 0xF << 14,
}

interface Token {
    kind: TokenKind,
    // TODO: flags?
    string: string,
    rawString: string,
    remaining: string,
}

export function getToken(string: string): Token | undefined {
    if (string === "") {
        return undefined;
    }

    let kind = TokenKind.Invalid, flags = NodeFlags.None;
    let len = 0;
    let skip = 0, chop = 0;

    // Scan forward, updating len, until the condition is false.
    // string[len] will be at the first non-matching char.
    function scan(charMatches: (char: string) => boolean) {
        for (; len < string.length; len++) {
            if (!charMatches(string[len])) {
                break;
            }
        }
    }

    switch (string[0]) {
        // Whitespace parsing
        case "\n": {
            kind = TokenKind.Newline;
            len += 1;
        } break;
        case " ": case "\r": case "\t": case "\f": case "\v": {
            kind = TokenKind.Whitespace;
            len += 1;
            scan(c => [" ", "\r", "\t", "\f", "\v"].includes(c));
        } break;

        // Comment parsing
        case "/": {
            if (string.length <= 1) {
                // TODO: goto symbol_lex ???!!!?
                break;
            }

            if (string[1] === "/") {
                // Trim off the first "//"
                skip = 2;
                len += 2;
                kind = TokenKind.Comment;
                scan(c => !["\n", "\r"].includes(c));
            } else if (string[1] == "*") {
                // Trim off the first "/*"
                skip = 2;
                len += 2;
                kind = TokenKind.BrokenComment;
                let commentDepth = 1;
                for (; len < string.length && commentDepth > 0; len += 1) {
                    if (len + 1 < string.length) {
                        if (string[len] === "*" && string[len+1] === "/") {
                            len += 1;
                            commentDepth -= 1;
                        } else if (string[len] === "/" && string[len+1] === "*") {
                            len += 1;
                            commentDepth += 1;
                        }
                    }
                }
                if (commentDepth === 0) {
                    kind = TokenKind.Comment;
                    chop = 2;
                }
            }
        } break;

        // Strings
        case "\"": case "'": case "`": {
            kind = TokenKind.BrokenStringLiteral;

            // Determine delimiter setup (which delimiter, is it a triplet)
            const delim = string[0];
            const isTriplet = string.length >= 3 && string[1] === delim && string[2] === delim;

            if (isTriplet) {
                // Lex a triple-delimited string
                skip = 3;
                len += 3;
                let consecutiveDelims = 0;
                for (; len < string.length; len++) {
                    if (string[len] === delim) {
                        consecutiveDelims += 1;
                        if (consecutiveDelims === 3) {
                            chop = 3;
                            kind = TokenKind.StringLiteral;
                            break;
                        }
                    } else {
                        consecutiveDelims = 0;

                        // escaping characters in string literals
                        // (it seems that only the current delimiter can be escaped?)
                        if (string[len] === "\\" && (string[len+1] === delim || string[len+1] === "\\")) {
                            len += 1; // extra bump to skip the char after the backslash
                        }
                    }
                }
            } else {
                // Lex a single-delimited string
                skip = 1;
                len += 1;
                for (; len < string.length; len++) {
                    // Close condition
                    if (string[len] === delim) {
                        chop = 1;
                        len += 1;
                        kind = TokenKind.StringLiteral;
                        break;
                    }

                    // Fail condition
                    if (string[len] === "\n") {
                        break;
                    }

                    // escaping characters in string literals
                    // (it seems that only the current delimiter can be escaped?)
                    if (string[len] === "\\" && (string[len+1] === delim || string[len+1] === "\\")) {
                        len += 1; // extra bump to skip the char after the backslash
                    }
                }
            }

            flags |= NodeFlags.StringLiteral;
            switch (delim) {
                case "'":  flags |= NodeFlags.StringSingleQuote; break;
                case "\"": flags |= NodeFlags.StringDoubleQuote; break;
                case "`":  flags |= NodeFlags.StringTick; break;
            }
            if (isTriplet) {
                flags |= NodeFlags.StringTriplet;
            }
        } break;

        // Identifiers, numbers, symbols
        default: {
            const identifierMatch = string.match(/^[a-zA-Z_][a-zA-Z0-9_]*/);
            const numericMatch = string.match(/^-?(0|[1-9][0-9]*)(\.[0-9]+)?([eE][-+]?[0-9]+)?/);

            if (identifierMatch) {
                flags |= NodeFlags.Identifier;
                kind = TokenKind.Identifier;
                len += identifierMatch[0].length;
            } else if (numericMatch) {
                flags |= NodeFlags.Numeric;
                kind = TokenKind.Numeric;
                len += numericMatch[0].length;
            } else if (charIsUnreservedSymbol(string[0])) {
                flags |= NodeFlags.Symbol;
                kind = TokenKind.Symbol;
                len += 1;
                scan(c => charIsUnreservedSymbol(c));
            } else if (charIsReservedSymbol(string[0])) {
                kind = TokenKind.Reserved;
                len += 1;
            } else {
                kind = TokenKind.BadCharacter;
                len += 1;
            }
        } break;
    }

    return {
        kind: kind,
        rawString: string.slice(0, len),
        string: string.slice(skip, len-chop),
        remaining: string.slice(len),
    }
}

function charIsUnreservedSymbol(c: string): boolean {
    return "~!$%^&*-=+<.>/?|".includes(c);
}

function charIsReservedSymbol(c: string): boolean {
    return "{}()\\[]#,;:@".includes(c);
}

class ParseContext {
    #source: string;
    #remaining: string;
    #last: Token | undefined;
    #errors: string[];

    constructor(source: string) {
        this.#source = source;
        this.#remaining = source;
        this.#errors = [];
    }

    check(
        kind: TokenKind | TokenGroup = TokenKind.All,
        cond: (token: Token) => boolean = () => true,
    ): Token | undefined {
        const token = getToken(this.#remaining);
        if (token && (token.kind & kind) && cond(token)) {
            return token;
        } else {
            return undefined;
        }
    }

    consume(
        kind: TokenKind | TokenGroup = TokenKind.All,
        cond: (token: Token) => boolean = () => true,
    ): Token | undefined {
        const token = this.check(kind, cond);
        if (token) {
            this.#remaining = token.remaining;
            this.#last = token;
        }
        return token;
    }

    consumeAll(
        kind: TokenKind | TokenGroup = TokenKind.All,
        cond: (token: Token) => boolean = () => true,
    ): Token[] {
        const tokens: Token[] = [];
        while (true) {
            const token = this.consume(kind, cond);
            if (!token) {
                break;
            }
            tokens.push(token);
        }
        return tokens;
    }

    done(): boolean {
        return !this.check();
    }

    error(msg: string) {
        this.debug(`ERROR! ${msg}`)
        this.#errors.push(msg);
    }

    debug(msg: string) {
        if (!DEBUG) return;
        console.log({
            msg,
            remaining: this.#remaining.slice(0, Math.min(30, this.#remaining.length)),
        });
    }

    get source(): string {
        return this.#source;
    }

    get last(): Token | undefined {
        return this.#last;
    }

    get offset(): number {
        return this.#source.length - this.#remaining.length;
    }

    get errors(): string[] {
        return this.#errors;
    }
}

/**
 * Grammar:
 * 
 *     [ tag-list ]
 *     (
 *         label [ ':' [ whitespace-line | newline ] ( [ whitespace-all ] explicit-list | implicit-list ) ]
 *         | explicit-list
 *     )
 */
export function _parseNode(ctx: ParseContext): Node | undefined {
    ctx.debug("parseNode");

    const startOffset = ctx.offset;

    const node = makeNode(NodeKind.Main, "", "");
    node.tags = _parseTagList(ctx);
    ctx.debug(`got ${node.tags.length} tags`);

    // Check if we should break into the case where it's just an explicit-list
    const explicitOpener = ctx.check(TokenKind.Reserved, t => "([{".includes(t.string));
    if (explicitOpener) {
        // Anonymous node (no string, just children)
        ctx.debug("node is anonymous");
        const [children, flags] = _parseExplicitList(ctx);
        node.children = children!;
        node.flags |= flags;
    } else {
        // Named node
        const label = ctx.consume(TokenGroup.Label);
        if (label) {
            node.string = label.string;
            ctx.debug(`node is named: ${node.string}`);
            
            const colon = ctx.consume(TokenKind.Reserved, t => t.string === ":");
            if (colon) {
                // Node has children

                // Optional whitespace / single newline before any children begin
                ctx.consumeAll(TokenKind.Whitespace);
                ctx.consume(TokenKind.Newline);

                const opener = ctx.check(TokenKind.Reserved, t => "([{".includes(t.string));
                if (opener) {
                    const [children, flags] = _parseExplicitList(ctx);
                    node.children = children!;
                    node.flags |= flags;
                } else {
                    node.children = _parseImplicitList(ctx);
                }
            }
        } else {
            ctx.error(`expected a valid node label, but got "${ctx.check()?.string ?? "end of file"}" instead`);
            return undefined;
        }
    }

    const endOffset = ctx.offset;
    node.rawString = ctx.source.slice(startOffset, endOffset);

    return node;
}

/**
 * Grammar:
 * 
 *     tag-list = '@' label [ '(' [ scoped-children-list ] ')' ] whitespace-all [ tag-list ]
 * 
 * For ease of parsing, we actually hand off to `_parseScopedChildren`, rather
 * than `_parseScopedChildrenList`, and then verify after the fact that you
 * used parentheses (the only valid delimiter for tag children).
 */
export function _parseTagList(ctx: ParseContext): Node[] {
    ctx.debug("parseTagList");

    const result: Node[] = [];

    while (true) {
        const at = ctx.consume(TokenKind.Reserved, t => t.string === "@");
        if (!at) {
            break;
        }

        const label = ctx.consume(TokenGroup.Label);
        if (!label) {
            ctx.error(`"${ctx.last?.rawString}" is not a proper tag label`);
            break;
        }

        ctx.debug(`tag is named: ${label.string}`);

        const tagNode = makeNode(NodeKind.Tag, label.string, label.rawString);
        const [tagChildren, tagFlags] = _parseExplicitList(ctx);
        tagNode.flags |= tagFlags;
        
        const childrenAreParenthesized = tagNode.flags&NodeFlags.HasParenLeft && tagNode.flags&NodeFlags.HasParenRight;
        if (tagChildren !== undefined && !childrenAreParenthesized) {
            ctx.error("tag children can only be delimited using parentheses");
        }
        tagNode.children = tagChildren ?? [];

        result.push(tagNode);

        ctx.consumeAll(TokenGroup.Whitespace);
    }

    return result;
}

/**
 * Grammar:
 * 
 *     ( '(' | '[' | '{' ) [ explicit-children ] ( ')' | ']' | '}' )
 * 
 * Note that, while the grammar allows for any combination of opening and closing delimiters, some
 * combinations are forbidden and will be validated separately.
 */
function _parseExplicitList(ctx: ParseContext): [Node[] | undefined, NodeFlags] {
    ctx.debug("parseExplicitList");

    let parentFlags: NodeFlags = 0;

    const opener = ctx.consume(TokenKind.Reserved, t => "([{".includes(t.string));
    if (!opener) {
        ctx.debug("no list")
        return [undefined, 0];
    }
    switch (opener.string) {
        case "(": parentFlags |= NodeFlags.HasParenLeft; break;
        case "[": parentFlags |= NodeFlags.HasBracketLeft; break;
        case "{": parentFlags |= NodeFlags.HasBraceLeft; break;
    }
    
    const children = _parseExplicitChildren(ctx);

    const closer = ctx.consume(TokenKind.Reserved, t => ")]}".includes(t.string));

    const isBraced = opener.string === "{" && closer?.string === "}";
    const isBracketed = opener && closer && (
        "([".includes(opener.string)
        && ")]".includes(closer.string)
    );
    if (!(isBraced || isBracketed)) {
        ctx.error(`"${opener.string}" and "${closer?.string}" cannot be used together`);
    }

    switch (closer?.string) {
        case ")": parentFlags |= NodeFlags.HasParenRight; break;
        case "]": parentFlags |= NodeFlags.HasBracketRight; break;
        case "}": parentFlags |= NodeFlags.HasBraceRight; break;
    }

    return [children, parentFlags];
}

/**
 * Grammar:
 * 
 *     [ whitespace-all ] node [ whitespace-all ] [ ',' | ';' | whitespace-all ] [ whitespace-all ] [ explicit-children ]
 * 
 * Since this part of the grammar only occurs within `explicit-list` and `file`, this function will
 * exit when it sees either a closing delimiter or the end of the token stream. It will not consume
 * the final delimiter, if any, so that `_parseExplicitList` can consume it.
 */
function _parseExplicitChildren(ctx: ParseContext): Node[] {
    const result: Node[] = [];

    let nextNodeFlags: NodeFlags = 0;
    while (true) {
        ctx.consumeAll(TokenGroup.Whitespace);

        const node = _parseNode(ctx);
        if (!node) {
            break;
        }
        node.flags |= nextNodeFlags;
        nextNodeFlags = 0;
        result.push(node); // this is JS, so we can continue to modify node after pushing it

        ctx.consumeAll(TokenGroup.Whitespace);

        // Check if we need to bail
        const endDelimiter = ctx.check(TokenKind.Reserved, t => ")]}".includes(t.string));
        if (endDelimiter || ctx.done()) {
            break;
        }

        const separator = ctx.consume(TokenKind.Reserved, t => ",;".includes(t.string));
        if (separator) {
            switch (separator.string) {
                case ",": {
                    node.flags |= NodeFlags.IsBeforeComma;
                    nextNodeFlags |= NodeFlags.IsAfterComma;
                } break;
                case ";": {
                    node.flags |= NodeFlags.IsBeforeSemicolon;
                    nextNodeFlags |= NodeFlags.IsAfterSemicolon;
                } break;
                // default: {
                //     ctx.error(`unexpected character ${separator.string} in a list of nodes`);
                // } break;
            }
        }

        ctx.consumeAll(TokenGroup.Whitespace);        
    }

    return result;
}

/**
 * Grammar:
 * 
 *     implicit-children ( ',' | ';' | newline )
 * 
 * Additionally, here is the grammar for `implicit-children`:
 * 
 *     [ whitespace-line ] node [ whitespace-line implicit-children ]
 * 
 * We parse the two together in a single function for simplicity.
 */
function _parseImplicitList(ctx: ParseContext): Node[] {
    ctx.debug("parseImplicitList");

    const result: Node[] = [];
    while (forever()) {
        ctx.consumeAll(TokenKind.Whitespace);

        const node = _parseNode(ctx);
        if (!node) {
            ctx.error("expected a node");
            break;
        }
        result.push(node);

        const nextIsSeparator = ctx.check(TokenKind.Reserved, t => ",;".includes(t.string));
        const nextIsNewline = ctx.check(TokenKind.Newline);
        if (nextIsSeparator || nextIsNewline) {
            ctx.consume(); // This is really part of processing `implicit-list`
            break;
        }

        const whitespaceBeforeNext = ctx.consumeAll(TokenKind.Whitespace);
        if (whitespaceBeforeNext.length === 0) {
            ctx.error("whitespace is required before the next node in the list");
            break;
        }
    }

    return result;
}

export enum GenerateFlags {
    Tags         = 1 << 0,
    TagArguments = 1 << 1,
    Children     = 1 << 2,
    Comments     = 1 << 3,
    NodeKind     = 1 << 4,
    NodeFlags    = 1 << 5,
    Location     = 1 << 6,
    
    Tree = (
        Tags
        | TagArguments
        | Children
    ),
    All = 0xffffffff,
}

export function debugDumpFromNode(
    node: Node,
    indent: number,
    indentString: string,
    flags: GenerateFlags,
): string {
    let out = '';

    // TODO: previous comment

    function printIndent() {
        for (let i = 0; i < indent; i++) {
            out += indentString;
        }
    }

    // tags
    if (flags & GenerateFlags.Tags) {
        for (const tag of node.tags) {
            printIndent();
            out += `@${tag.string}`;
            if (flags & GenerateFlags.TagArguments && tag.children.length > 0) {
                const tagArgIndent = indent + 1 + tag.string.length + 1;
                out += "(";
                for (const [i, child] of tag.children.entries()) {
                    if (i > 0) {
                        out += ",\n";
                    }
                    let childIndent = i === 0 ? 0 : tagArgIndent;
                    out += debugDumpFromNode(child, childIndent, " ", flags);
                }
                out += ")\n";
            } else {
                out += "\n";
            }
        }
    }

    // node kind
    if (flags & GenerateFlags.NodeKind) {
        printIndent();
        out += `// kind: "${node.kind}"\n`; // TODO: stringFromNodeKind
    }

    // node flags
    if (flags & GenerateFlags.NodeFlags) {
        printIndent();
        const flagsStr = stringListFromNodeFlags(node.flags).join("|");
        out += `// flags: "${flagsStr}"\n`;
    }

    // location
    // TODO

    // name of node
    if (node.string) {
        printIndent();
        if (node.kind === NodeKind.File) {
            out += `\`${node.string}\``;
        } else {
            out += node.string; // TODO: in ryan's code, this is the raw string instead??
        }
    }

    // children list
    if (flags & GenerateFlags.Children && node.children.length > 0) {
        if (node.string) {
            out += ":\n";
        }
        printIndent();
        out += "{\n";
        for (const child of node.children) {
            out += debugDumpFromNode(child, indent + 1, indentString, flags);
            out += ",\n";
        }
        printIndent();
        out += "}";
    }

    // next comment
    // TODO

    return out;
}

function stringListFromNodeFlags(flags: NodeFlags): string[] {
    return ["flag", "lol"]; // TODO
}

function* forever() {
    for (let i = 0; i < 10000; i++) {
        yield true;
    }
    throw new Error("a loop ran on too long");
};
